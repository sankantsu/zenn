---
title: "OSC 52 で出力をクリップボードにコピーするためのワンライナー"
emoji: "📎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["shell", "シェル芸", "clipboard"]
published: true
---

## TL;DR

以下のコマンドで `./cmd` の出力をクリップボードにコピーできる。

```sh
$ ./cmd | base64 | tr -d "\n" | xargs -I{} echo -n $'\x1b]52;;{}\x1b\\'
```

## OSC 52 とは?

OSC は Operating System Command の略です。
Operating System Command は何かというと、`ESC ] ... ESC \` の並びのエスケープシーケンスのことです (`ESC` は `0x1b` の 1 byte)。
`ESC ]` の直後に数字が続くパターンが多く、特に `ESC ] 52` を先頭にしたエスケープシーケンスを OSC 52 といいます。

それで、この OSC 52 が何をしてくれるのかというと、テキストをクリップボードにコピーすることができます。
具体的な書式は以下のようになっています (空白は実際には入力しません)。

```
ESC ] 52;<Pc>;<Pd> ESC \
```

c.f. [XTerm Control Sequences: Operating System Commands](https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands)

`<Pc>` はクリップボードの種類を表わす文字列です。空だと `s0` と同じ意味になるようです。詳しい説明は XTerm Control Sequences のページを参考にしてください。
`<Pd>` はクリップボードにコピーしたいデータを base64 エンコーディングした文字列です。

一つ例を試してみましょう。
`foo` という文字列をクリップボードにコピーしたいとします。まずは base64 エンコーディングしてみます。

```sh
$ echo -n foo | base64
Zm9v
```

base64 エンコードした結果 `Zm9V` という文字列になることがわかりました。
これを OSC 52 のエスケープシーケンスに埋めこんで実行します。

```sh
$ echo -n -e "\e]52;;Zm9v\e\\"
```

この状態で `Ctrl + V` などでペーストしてみると、`foo` という文字列が入っているのが確認できると思います。

:::message
エスケープシーケンスはカーソルを動かしたりテキストの色を変えたりするものというイメージが強いかもしれません。
実際のところ、もう少し一般的に見ればエスケープシーケンスというのは「端末が解釈して何か必要な操作を行ってくれるもの」です。端末に対する API がエスケープシーケンスというちょっと風変わりなインターフェースで実装されているものとでも思えば良いでしょう。
したがって、端末がそういう機能さえ実装していれば「テキストをクリップボードにコピーする」なんていう芸当もできるわけです。
:::

## OSC 52 は何がうれしいの?

コマンドの出力コピーするだけなら `pbcopy` とか `clip.exe` とか `xsel -b` とか使えばいいじゃんと思う方もいらっしゃるかもしれません。
確かにローカルの開発環境で使うだけなら以上のようなコマンドに標準出力を流せば十分です。

しかし、よく困るのが SSH でリモートに接続した際のコピーではないでしょうか?
X11 Forwarding を設定していれば `xsel -b` 等を用いてコピーしてくることはできるのですが、ローカルに X server を立てておかないといけないとか、リモート側に `xsel` コマンドを入れとかないといけないとか、そもそも X11 Forwarding が許可されていない場合があるとか、いろいろと面倒臭い部分も多いのです。

OSC 52 は端末が処理するので、SSH していようと何だろうと端末さえ OSC 52 に対応していれば簡単に使うことができるのが嬉しいポイントです。
唯一注意すべきなのは、端末が対応しているか、また対応しているとして有効化しているかという点になります。筆者が普段使っている Wezterm は特に設定しなくても OSC 52 が有効になっているようです。

### tmux 用の設定

SSH 先では `tmux` を使う方が多いでしょう。
`tmux` は端末上で動いているアプリケーションの出力を一回 `tmux` 側で吸いとって、場合によってはいろいろと処理をしてから外側の実際の端末エミュレータに渡してくるので、ちょっと注意が必要です。
OSC 52 に関しては基本は以下を `.tmux.conf` に設定しておけば良いと思います。

```
set-option -s set-clipboard on
```

詳しくは以下などを参考にしてください。

https://zenn.dev/tennashi/scraps/04e226127a4b1d

https://github.com/tmux/tmux/wiki/Clipboard

## ワンライナーでコピー

さて、本題のワンライナーです (bash, zsh 用です)。
以下のワンライナーで `./cmd` の標準出力をクリップボードにコピーできます。
(2024/12/22 追記: `tr -d "\n"` を追加)

```sh
$ ./cmd | base64 | tr -d "\n" | xargs -I{} echo -n $'\x1b]52;;{}\x1b\\'
```

まず、OSC 52 のデータ部分は base64 エンコードしたデータじゃないといけないので、最初に `base64` コマンドに通します。
次に、`tr -d "\n"` で改行を削除します。これは、`base64` コマンドが実装によっては適当な幅ごとに改行することで整形した出力を返すことがあるためです ^[GNU Coreutils 版の `base64` は出力をデフォルトで 76 文字区切りで改行するようです (参考: [GNU Coreutils online manual](https://www.gnu.org/software/coreutils/manual/html_node/base64-invocation.html))。`tr -d "\n"` で改行を削除する変わりに `base64 -w 0` で改行を抑制することも可能です。一方、MacOS 版の `base64` は全体の出力の末尾以外には改行を付加しないようです。したがって MacOS 環境なら `tr -d "\n"` を入れなくてもそれほど問題無いはずです。ただし、MacOS 版 `base64` は `-w` オプションを受けつけないので、GNU Coreutils 版を前提に `-w 0` を使っていると MacOS 版では動かなくなりやや移植性が下がります。今回はどちらの環境でも動くバージョンとして `tr -d "\n"` を使用します]。このように改行が含まれていると、後段の `xargs` は行ごとに独立にコマンドを実行してしまいます。今回は `base64` データ全体をひとつにまとめて扱いたいので、改行を事前に消しておく必要があります。

次に、標準入力の base64 データをエスケープシーケンスを出力する `echo` に埋めこみたいのでプレースホルダー (`-I{}` ) 付きで `xargs` コマンドを使います。
このときちょっと注意が必要なのが、`echo` は `xargs` から起動されるのでシェル組み込みではなく外部コマンドの `/bin/echo` 等が呼ばれるという点です。すると、`\e` -> `ESC` 等を解釈してくれる`-e` オプションが使えなかったりすることがあります ^[筆者の使っている Mac 環境だと使えませんでした。Linux 環境なら GNU Coreutils 版が入っていることが多いと思うのでたぶん `-e` オプションも使えることが多いと思います]。
そこで、`$'...'` という bash/zsh の特殊なクオートを使っています ^[[man bash(1): QUOTING](https://www.man7.org/linux/man-pages/man1/bash.1.html#QUOTING)]。この `$'...'` の中では `\xHH` の形式の 16進記法を対応する 1 byte に展開してくれるので今回のテクニックが成立します。

## 便利なシェル関数・シェルスクリプトもあるよ

正直なところ、何回も使うのであればたぶん以下のようなシェル関数やシェルスクリプトを使ったほうが良いです。

https://gist.github.com/ttdoda/6c30de9a5f2112e72486

https://github.com/libapps/libapps-mirror/blob/main/hterm/etc/osc52.sh

関数定義するのもめんどいし、シェルスクリプト持ってくんのもめんどくさいし、とにかく今 1 回だけコピーしてきたいんじゃ！ってときにサッとワンライナーで書けたら役に立つ...かもしれません。
以上
